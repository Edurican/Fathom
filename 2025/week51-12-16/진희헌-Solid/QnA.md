# Q&A: [SOLID 원칙]

> 📅 2025.12.16 | 🧑‍💻 진희헌

---

## 👥 팀원 질문

### Q1. 만약 SOLID 원칙을 안 지키게 된다면 무조건 잘못된건가요? (질문자: 강윤혜)

**A.**
SOLID 원칙은 개발자들끼리 정리해 놓은 좋은 설계를 위한 추천 가이드라인이지, 반드시 지켜야 하는 규칙은 아닙니다. 예를 들어, 과도한 추상화는 오히려 가독성과 생산성을 떨어뜨릴 수 있습니다. 하지만, 만약 프로젝트 규모가 크고 변화가 많다면, SOLID 원칙을 지키며 향후 변경 가능성을 함께 고려하는 것이 합리적인 접근이라고 생각합니다.

---

### Q2. 가장 중요한 SOLID 원칙이 무엇이라고 생각하시나요?  (질문자: 송형욱)

**A.**
저는 리스코프 치환 원칙 이 SOLID 원칙 중에서 가장 중요하다고 생각합니다. 리스코브 치환 원칙은 상속 관계를 만드는 규칙이 아니라, 부모 타입을 사용하는 모든 코드에서 자식 타입이 언제나 문제없이 동작해야 한다는 설계상의 약속을 의미합니다.  즉, 자식 클래스는 부모 클래스의 기대 동작을 깨뜨리지 않아야 하며, 이를 통해 상속이 문법적 수단이 아니라 설계적으로 타당한지 명확해야 됩니다. 만약 이 원칙을 안 지킬시 컴파일 에러는 발생하지 않지만 런타임 오류나 예상치 못한 동작으로 이어지는 경우가 많기 때문입니다.

---

## 🤖 AI 생성 질문 (Antigravity)

> Antigravity를 활용하여 발표 내용 기반 질문을 생성합니다.

### Q1. 클래스의 책임을 분리하는 기준은 무엇이며, 어떻게 결정할 수 있을까요?

**A.**
클래스의 책임을 분리하는 기준은 한 클래스가 두 가지 이상의 변경 이유를 가지는지 여부입니다. 여기서 책임은 단순한 기능의 개수가 아니라, 왜 변경되는가(변경 이유) 로 판단하는 것이 중요합니다. 예를 들어 계산기 클래스의 경우, 계산 로직의 개선이나 오류 수정이라는 하나의 변경 이유만 가진다면 단일 책임을 지킨다고 볼 수 있습니다. 반면 계산 기능 외에 출력 형식 처리나 로그 기록까지 함께 담당한다면, 서로 다른 변경 이유가 발생하므로 책임 분리가 필요합니다.

---

### Q2. 개방/폐쇄 원칙을 지키지 않을 경우의 단점과 유지보수 비용으로 이어지는 예시를 설명할 수 있을까요?

**A.**
개방/폐쇄 원칙이 지켜지지 않을 경우, 시스템은 확장성은 낮아지고 유지보수 비용은 증가하게 됩니다. 예를 들어 하나의 클래스 내부에 복잡한 if-else if 조건문이 반복적으로 사용되는 구조에서는 새로운 기능이나 조건이 추가될 때마다 기존 코드를 직접 수정해야 합니다. 이 과정에서 기존 로직에 영향을 줄 가능성이 커지고, 수정 범위가 넓어질수록 버그 발생 위험도 함께 증가합니다. 결과적으로 OCP를 지키지 않은 설계는 기능 확장이 곧 기존 코드 수정으로 이어지며, 장기적으로 높은 유지보수 비용을 초래하게 됩니다.

---

### Q3. 단일 책임 원칙과 개방/폐쇄 원칙을 모두 고려하여 실제 개발 프로젝트에서 설계 결정에 이를 어떻게 적용할 수 있을까요?

**A.**
실제 개발 프로젝트에서는 초기 설계 단계에서 단일 책임 원칙을 통해 변경 이유를 기준으로 책임을 분리하고, 그중 변경 가능성이 높은 부분에 대해 개방/폐쇄 원칙을 적용합니다. 즉, 먼저 각 클래스의 역할을 명확히 나눈 뒤, 기능 확장이 예상되는 지점을 인터페이스나 추상 클래스로 감싸는 방식으로 설계합니다. 이를 통해 기존 코드를 수정하지 않고도 새로운 기능을 추가할 수 있으며, 유지보수성과 확장성을 동시에 확보할 수 있습니다.

---

### Q4. 실무에서 SOLID 원칙을 적용하여 개발한 시스템이 발생할 수 있는 장단점을 비교하면 어떨까요?

**A.**
실무에서 SOLID 원칙을 적용한 시스템의 가장 큰 장점은 변화에 유연하게 대응할 수 있다는 점입니다. 각 클래스의 역할이 명확하고 결합도가 낮기 때문에, 기능 추가나 정책 변경 시 수정 범위가 제한되며 테스트와 유지보수가 용이합니다. 반면 단점으로는, 초기 설계 단계에서 클래스와 인터페이스의 수가 증가할 수 있으며 구조를 이해하는 데 시간이 더 소요될 수 있다는 점이 있습니다. 또한 모든 코드에 무분별하게 SOLID 원칙을 적용할 경우 과도한 추상화로 인해 오히려 복잡성이 증가할 수 있습니다. 따라서 실무에서는 변경 가능성이 높은 영역에 선택적으로 적용하는 균형 잡힌 접근이 중요합니다.

---

### Q5. SOLID 원칙을 반영하여 설계된 시스템의 확장성과 유지보수성을 어떻게 평가할 수 있을까요?

**A.**
SOLID 원칙이 잘 반영된 시스템은 우선 높은 가독성을 가집니다. 각 클래스의 책임이 명확하여 어떤 로직이 어디에 위치해야 하는지 쉽게 파악할 수 있습니다. 또한 새로운 기능을 추가할 때 기존 코드의 수정이 최소화된다면 해당 시스템은 확장성이 높다고 평가할 수 있습니다. 유지보수 측면에서는, 특정 기능의 변경이 다른 기능에 영향을 주지 않고 독립적으로 수정 및 테스트가 가능하다면 유지보수성이 우수한 설계라고 볼 수 있습니다. 즉, 변경 시 영향 범위가 작고 확장이 자연스러운 구조인지가 확장성과 유지보수성을 평가하는 핵심 기준이 됩니다.

---

## 💭 추가 고민

### Q1. Service 계층 같은 경우 여러 비지니스 로직이 하나의 흐름으로 묶이는데, 단일 책임을 적용한다면 분리해야 될까?  

**A.**
Service 계층은 여러 비즈니스 로직을 하나의 유스케이스 흐름으로 조합하는 역할을 하기 때문에, 여러 로직이 포함되어 있더라도 무조건 분리해야 하는 것은 아닙니다. 단일 책임 원칙에서 말하는 책임은 기능의 개수가 아니라 변경 이유이므로, 해당 로직들이 동일한 비즈니스 정책 변화에 의해 함께 수정된다면 하나의 Service에 존재해도 단일 책임을 위반하지 않습니다. 다만, Service 내부에 포함된 로직이 다른 유스케이스에서도 재사용되거나, 독립적으로 변경될 가능성이 높다면 이는 별도의 컴포넌트나 도메인 서비스로 분리하는 것이 바람직합니다.

---

## 🔗 추가 학습 자료

답변하면서 찾아본 자료들:

- [자료 1](링크)
- [자료 2](링크)
