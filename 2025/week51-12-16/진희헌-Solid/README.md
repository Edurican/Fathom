# [Solid 원칙]

> 📅 2025.12.16 | 🧑‍💻 진희헌 | 🏷️ SRP, OCP, LSP, ISP, DIP 

---

## 🎯 개요

### 이 주제를 선택한 이유

CRUD의 근간이 되는 게시판과 댓글을 구현을 하게됐다. 기능을 구현하는 것은 큰 문제가 되지 않았지만, 설계를 진행할수록 각 기능을 어느 위치에 두는 것이 적절한지에 대해 어려움을 느끼게 되었다. 하나의 클래스에 책임을 어디까지 부여해야 하는지, 특정 로직을 분리하는 기준은 무엇인지에 고민하게 됐다. 그리고 이는 구조적으로 잘 설계된  코드를 작성해 보고싶다는 마음이 들었고, 다음 질문으로 이어졌다.  “어떻게하면 더욱 객체지향적인 설계를 할 수 있을까? “  그리거,  OOP 의 4대 특징과 같은 기본적인 개념을 뒤돌아보며  OOP 위한 핵심적인 원칙인 솔리드 5원칙에 대해서 알게 됐습니다. 따라서, 보다 개선된 OOP 설계를 위해 솔리드 5원칙을 주제로 선정하게 됐습니다.

### 목표

이 발표를 통해:

- 변화대응에 빠르고 유지보수가 비용이 낮은 OOP 설계를 하자.

---

## 📖 본문

### 1. 섹션 제목

단일 책임 원칙(SRP)는 하나의 클래스는 하나의 책임만 가져야 된다는 원칙이다. 여기서 말하는 책임은 클래스의 기능을 생각해보면 이해하기 쉽다. 예를 들어, 계산기 클래스에는 계산하는 기능이 있을것이고, 시계 클래스에는 시간을 알려주는 기능이 있다. 만일 코드를 변경해야 되는 상황이 있다면,  그들의 기능을 위해 변경어야 된다. 즉, 하나의 클래스는 하나의 이유로만 변경이되어야 된다.
클래스에 기능이 늘어나게 된다면, 클래스가 점점 무거워지고 담당하는 역할이 많이지게 되며, 그만큼 변경의 이유 또한 증가하게 됩다. 다시 말해, 하나의 클래스가 동시에 여러개의 책임을 지고 있는 경우, 기능의 문제가 발생하게 된다면 클래스 전체를 수정해야 된다. 결국 이는 높은 유지보수 비용으로 이어진다.  
이러한 문제를 예방하기 위해서는 단일 책임 원칙을 지향해야 한다. 하나의 클래스에 여러 기능을 모두 포함시키기보다는, 각 기능을 담당하는 클래스를 분리하여 관리하고, 상위 또는 메인 클래스에서는 이 기능들을 조합하고 호출하는 역할만 수행하도록 설계하는 것이 단일 책임 원칙의 핵심이다. 따라서, 이와 같은 구조에서는 특정 기능에 문제가 발생하더라도 해당 기능을 담당하는 클래스만 수정하면 되므로, 변경 범위가 명확해지고 유지보수가 더욱 편리진다.

### 2. 섹션 제목

개방/폐쇄 원칙(OCP)은 소프트웨어 개발의 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다는 원칙이다. 기존 코드들은 가능한 수정하지 않고도 확장성 대응에는 빨라야 된다는 것이 개방 폐쇄의 핵심점이다.
개방 폐쇄 원칙이 잘 지켜지지 않는다면 비용 문제로 직결된다. 예를 들어,   if-elseif문이 덕지덕지 써져있는 클래스에 새로운 변수가 추가될 경우를 생각해 봤을 때, 개발자는 기존 조건문 코드를 수정하여 새로운 조건을 추가해야된다. 조건문을 사용하는 것이 잘못된 방식은 아니지만, 이러한 구조는 기능이 추가되면 추가될 수록 높은 수정 빈도로 이어질 것이다.  
이 문제는 설계 단계에서 개방/폐쇄 원칙을 준수함으로서 예방할 수 있다. 초기 설계 단계에서 공통된 동작을 인터페이스로 추상화하고 이를 구현하는 방식으로 구조를 설계한다면, 새로운 기능이 추가되더라도 기존 코드를 수정할 필요가 없이 확장할 수 있다. 이러한 설계에서는 새로운 기능을 인터페이스의 구현체로 추가하는 것만으로 확장이 가능하므로, 기존 코드의 안정성을 유지하면서도 빠른 확장이 가능해진다.


### 3. 섹션 제목

셋째로 리스코프의 치환 원칙은 상위 타입의 객체를 사용하다가 그 상위타입을 상속받은 하위 타입의 객체를 사용하게 되더라도 프로그램의 동작이 변하지 않고 정상작동 되어야 된다는 원칙이다. 즉, 상속 관계에 있는 클래스들은 반드시 논리적으로 일관성을 유지해야 되며, 만일 이것이 지켜지지 않는다면 결국 오류를 발생 시킨다.
이 원칙은 행위와 규약의 관점에서 부모와 자식 클래스간의 호환이 얼마나 중요한지 나타낸다. 만약 자식 클래스가 부모 클래스에서 정의된 동작에 제한이 있거나, 예외를 발생기킨다면, 프로그램 전체의 동작을 멈추게 만드는 큰 문제를 유발시킬 수 있다. 이같은 경우가 바로 리스코프 위반한 설계이다. 결국, 이는 다형성을 전제로한 설계의 안전성을 무너뜨리며, 유지 보수성을 크게 저하시킨다.
따라서, 리스코프 치환 원칙은 “자식 클래가 부모 클래스를 완전히 대체할 수 있는가?”를  기준으로 초기 설계에 지속적으로 고려해야만 된다. 이 원칙을 적용한 설계는 안정적인 다형성을 보장하며, 확장 가능한 객체지향 설계를 가능하게 할것이다.

### 4. 섹션 제목

인터페이스 분리 원칙은 말그대로 인터페이스를 목적과 용도에 맞게 적절하게 분리해서 설계햐야 된다는 원칙이다.  이 때 주의해야 될 점은 한번 분리한 인터페이스를  또 다시 분리하지 않게 초기 설계에 잘해야된는 것이 중요하다.  또한, 설계를 할 때  하나의 인터페이스를  여러 클래스가  공통으로 구현하독록 집중하기보다는,  각 클래스가 사용하는 기능만을 포함한 인터페이스에 의존하도록 설계해야된다.
인터페이스 분리 원칙의 핵심 포인트는, 인터페이스를 가능한 세분화시켜서 나눠야 된다는 것이 아닌,  초기 설계 단계에서 역할과 책임을 명확히 정의해야 된다는 것이다. 한 번 분리된 인터페이스를 또 다시 분리하는 상황을 반복하게 된다면, 이는 초기 설계 단계에서 책임 분리가 충분히 되었는지 뒤돌아 봐야 될것이다.  
인터페이스 분리 원칙을 적용할 때에는, 각 인터페이스가 명확한 목적을 가지도록 설계하고, 구현 클래스가 불필요한 메서드에 의존하지 않도록 주의해야 된다.


### 5. 섹션 제목

의존성 역전은 클래스가 다른 클래스를 참조하려고 할때,  그 구현 클래스에 직접 참조를 지양하고 그 클래스의 상위 요소를 참조하는 원칙이다.  즉, 객체 간의 의존 관계는 구현이 아닌 인터페이스나 추상 클래스와 같은 추상화에 기반이 된다.

이 원칙의 핵심은 의존성의 방향을 역전시키는 데 있다. 만약 상위 모듈이 하위 모듈의 구현에 직접 의존하게 되면, 하위 모듈의 변경이 상위 모듈에 그대로 영향을 미치게 된다.  예를 들어, 기존 코드가 수정되는 경우는 하위 모듈에서 제한되어야 되는데, 상위 모듈이 구현 클래스를 직접 의존하고 있다면 하위 모듈 역시 함께 수정해만 한다. 이는 상위 모듈이 책임지고 있는 비지니스 로직과는 무관한 이유로 변경된다는것을 뜻한다.
반면, 인터페이스를 기준으로 의존성을 설계하면, 구현 클래스가 변경되거나 교체되더라도 상위 모듈은 영향을 받지 않데 된다.  의존성 역전 원칙을 적용하면, 구현 세부사항으로부터 상위 로직을 분리할 수 있으며, 전체적인 구조의 결합도를 낮추고 확장성을 변화대응력을 향상시킬 수 있다.

---

## 🎬 결론

### 핵심 요약

1. 단일 책임 원칙(SRP)는 하나의 클래스는 하나의 책임만 가져야 된다는 원칙이다.
2. 개방/폐쇄 원칙(OCP)은 소프트웨어 개발의 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다는 원칙이다.
3. 셋째로 리스코프의 치환 원칙은 상위 타입의 객체를 사용하다가 그 상위타입을 상속받은 하위 타입의 객체를 사용하게 되더라도 프로그램의 동작이 변하지 않고 정상작동 되어야 된다는 원칙이다.
4. 인터페이스 분리 원칙은 말그대로 인터페이스를 목적과 용도에 맞게 적절하게 분리해서 설계햐야 된다는 원칙이다.
5. 의존성 역전은 클래스가 다른 클래스를 참조하려고 할때,  그 구현 클래스에 직접 참조를 지양하고 그 클래스의 상위 요소를 참조하는 원칙이다.

### 느낀 점

AOP 와 OOP에 대해서 공부해보자! 

---
