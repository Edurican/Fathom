# [교착상태]

> 📅 2025.12.30 | 🧑‍💻 이관호 | 🏷️ os, deadlock

---

## 🎯 개요

### 이 주제를 선택한 이유

실제 시스템에서 데드락이 발생할 수 있는데 어떻게 발생하고 해결할 수 있는지 궁금하였습니다.

### 목표

이 발표를 통해:

- 데드락 발생 4가지 조건 이해
- 데드락 해결 방법 이해

---

## 📖 본문

### 1. 교착상태(deadlock)란?

두 개 이상의 프로세스가 서로의 자원을 기다리며 무한히 대기하는 상태를 의미

### 2. 교착상태 발생조건

이해를 돕기 위해 식하는 철학자 문제를 바탕으로 구성하였습니다. </br>
원형 테이블에 5명의 철학자가 앉아있고 각 철학자 사이에 포크가 1개씩, 총 5개가 존재합니다. </br>
철학자는 "생각하기"와 "식사하기"를 반복하게 됩니다. </br>
식사하려면 양쪽 포크 2개가 모두 필요합니다. </br>

#### 상호배제
자원을 한 번에 하나의 프로세스/스레드만 사용 가능 </br>
즉, 포크 하나를 두 철학자가 동시에 사용할 수 없음을 의미 </br>

#### 점유대기
자원을 점유한 상태에서 다른 자원을 추가로 요청하며 대기 </br>
즉, 왼쪽 포크를 잡은 상태에서 오른쪽 포크를 요청하며 대기하는 상태를 의미 </br>

#### 비선점
다른 프로세스의 자원을 강제로 빼앗을 수 없음 </br>
즉, 옆 철학자의 포크를 강제로 빼앗을 수 없는 것을 의미 </br>

#### 순환대기
프로세스들이 순환 형태로 서로의 자원을 대기 </br>
즉, 철학자자를 P라고 가정한다면 P1→P2→P3→P4→P5→P1 원형 대기 고리 형성됨 </br>

### 3. 교착상태 해결법

데드락을 해결하기 위한 해결법이 존재
- 예방
- 회피
- 탐지
- 무시

#### 예방
4가지 조건 중 하나 이상을 원천적으로 제거하여 데드락이 발생하는 것을 예방함
즉, 모든 철학자가 포크 번호가 낮은 것부터 잡는 방식 (락 잠금 순서, 순환 대기 예방)

철학자가 반드시 포크 번호가 낮은 것부터 시작한다면
1. P1이 F1을 먼저 시도하여 선점하였다면
2. P2또한 F1을 먼저 시도하지만 P1이 보유중이기에 대기를 하게 됩니다
3. P2는 F1을 못잡았는지 F2도 잡지 않습니다

이를 통해 기존 P1→P2→P3→P4→P5→P1의 순환대기 조건이 </br>
모두 낮은 번호부터 집으면 P1←P2←P3←P4←P5로 대기 방향이 한쪽으로만 흐르기 때문에 </br>
결론적으로 순환대기 조건이 깨지게 됩니다 </br>

#### 회피
자원 할당 전 안전 상태인지 확인 </br>
즉, 포크 집기 전에 "둘 다 가능한가?"를 확인하는 방식 </br>

보통 은행원 알고리즘이 대표적인 회피방법입니다. </br>
은행원 알고리즘은 프로세스가 자원 요청을 하면 일단 할당했다고 가정하고 상태를 업데이트 합니다. </br>
이 후 안전 순서가 존재하는지 시뮬레이션을 하게 됩니다. </br>

만약 존재한다면 할당을 승인하는데 이를 안전상태라고 합니다. </br>
존재 하지 않는다면 롤백시키는데 이를 불안전상태라고 합니다. </br>

| 정보         | 설명 |
|------------|-----|
| Available  | 현재 사용 가능한 자원 수 |
| Max	| 각 프로세스가 최대로 필요한 자원 수 |
| Allocation	| 각 프로세스가 현재 보유한 자원 수 |
| Need	| 각 프로세스가 추가로 필요한 자원 수(Max - Allocation) |

축약하여 철학자와 포크가 각각 3개라고 가정하겠습니다  </br>
그냥 한명씩 포크를 잡아버리고 추가요청을 하면 데드락이 발생할겁니다. </br>

하지만 시뮬레이션을 통해 안정상태가 있는지 확인한다면? </br>

|철학자	| Max Allocation |	Need |
|----|-----|----|
|P1	|2	|2	|0 |
|P2	|2	|1	|1 |
|P3	|2	|0	|2 |

| 철학자	 | Max Allocation | 	Need |
|------|-----|-------|
| P1	  |2	| 0	    |2 |
| P2	  |2	| 2	    |0 |
| P3	  |2	| 0	    |2 |

| 철학자	 | Max Allocation | 	Need |
|------|-----|-------|
| P1	  |2	| 0	    |2 |
| P2	  |2	| 2	    |0 |
| P3	  |2	| 0	    |2 |

| 철학자	 | Max Allocation | 	Need |
|------|-----|-------|
| P1	  |2	| 0	    |2 |
| P2	  |2	| 0	    |2 |
| P3	  |2	| 2	    |0 |

실제 실무에는 불가능 하지 않을까? </br>
시스템의 모든 프로세스와 자원의 최대 요구량을 미리 알고 있어야하는 등... </br>
비현실적인 제약 조건과 복잡성이 존재하며 사용하지 못할거 같음 </br>

#### 탐지
일단 발생하도록 허용하고 발견하면 복구한다
즉, 일정 시간 대기 후 포크 내려놓고 재시도

#### 무시

---

## 🎬 결론

데드락을 해결하기 위한 조건을 알 수 있음
실무적인 해결방안을 일부 터득할 수 있음

### 핵심 요약

1. 실제 시스템에 문제 발생 가능한 데드락을 조심하자
2. 데드락을 해결할 수 있는 방안을 활용하자

### 느낀 점

DB 트랜잭션, 멀티스레드, 분산 시스템에서 모두 데드락이 발생할 수 있습니다. </br>
그렇기에 발생 조건과 해결법을 기억하며 구현할 수 있도록 신경써야겠다고 생각했습니다. </br>

---

## 📚 References

- [공식 문서](링크)
- [참고 블로그](링크)
- [GitHub 예제](링크)
